#!/usr/bin/env python3

# This script generates layout.cpp from layout.json

import sys
import re
import argparse
import io
import json

parser = argparse.ArgumentParser(description="Process some windows resources.")
parser.add_argument('-i', type=str, required=True, help='The json file to process')
parser.add_argument('-o', type=str, required=True, help='The implementation file to output')
args = parser.parse_args()

def print_header(f):
    f.write("// This file is auto-generated by layout.py\n\n")
    f.write("#include <ion/src/simulator/shared/layout.h>\n")
    f.write("#include <ion/src/simulator/shared/window.h>\n")
    f.write("#include <ion/src/simulator/shared/platform.h>\n")
    f.write("#include <ion.h>\n")
    f.write("#include <limits.h>\n")
    f.write("#include <cmath>\n")

    f.write("namespace Ion2 {\n")
    f.write("namespace Simulator {\n")
    f.write("namespace Layout {\n")

    f.write("#if !EPSILON_SDL_SCREEN_ONLY\n")

def print_sdl_frect(f, name, values):
    f.write("constexpr static SDL_FRect " + name + " = {X(" + str(values[0]) + "), Y(" + str(values[1]) + "), X(" + str(values[2]) + "), Y(" + str(values[3]) + ")};\n")

def print_background_areas(f, background_values):
    background_area = background_values["background"]
    f.write("constexpr static int backgroundWidth = " + str(background_area[2]) + ";\n")
    f.write("constexpr static int backgroundHeight = " + str(background_area[3]) + ";\n")

    f.write("constexpr static float X(int x) { return static_cast<float>(x)/static_cast<float>(backgroundWidth); }\n")
    f.write("constexpr static float Y(int y) { return static_cast<float>(y)/static_cast<float>(backgroundHeight); }\n")

    print_sdl_frect(f, "areaOfInterest", background_values["area_of_interest"])
    print_sdl_frect(f, "screenRect", background_values["screen"])

def print_before_keys(f):
    f.write("static SDL_Rect sFrame;\n")

    f.write("static void makeAbsolute(const SDL_FRect f, SDL_Rect * r) {\n")
    f.write("  r->x = std::round(f.x * static_cast<float>(sFrame.w) + static_cast<float>(sFrame.x));\n")
    f.write("  r->y = std::round(f.y * static_cast<float>(sFrame.h) + static_cast<float>(sFrame.y));\n")
    f.write("  r->w = std::round(f.w * static_cast<float>(sFrame.w));\n")
    f.write("  r->h = std::round(f.h * static_cast<float>(sFrame.h));\n")
    f.write("}\n")

    f.write("static void makeAbsolute(const SDL_FPoint f, SDL_Point * p) {\n")
    f.write("  p->x = f.x * sFrame.w + sFrame.x;\n")
    f.write("  p->y = f.y * sFrame.h + sFrame.y;\n")
    f.write("}\n")

    f.write("void recompute(int width, int height) {\n")
    f.write("  float windowWidth = static_cast<float>(width);\n")
    f.write("  float windowHeight = static_cast<float>(height);\n")
    f.write("  float aoiRatio = (areaOfInterest.w / areaOfInterest.h) * (static_cast<float>(backgroundWidth)/static_cast<float>(backgroundHeight));\n")
    f.write("  float windowRatio = windowWidth/windowHeight;\n")
    f.write("  if (aoiRatio > windowRatio) {\n")
    f.write("    // Area of interest is wider than the window (e.g. aoe 16:9, window 4:3)\n")
    f.write("    // There will be \"black bars\" above and below\n")
    f.write("    // We want the areaOfInterest's rect in pixels to be\n")
    f.write("    // aoiInPixels.w = windowWidth\n")
    f.write("    // aoiInPixels.x = 0\n")
    f.write("    // aoiInPixels.h = windowWidth / (aoiRatio*deviceRatio)\n")
    f.write("    // aoiInPixels.y = (windowHeight - aoiInPixels.h)/2\n")
    f.write("    // But we also know that\n")
    f.write("    // aoiInPixels.x = sFrame.x + areaOfInterest.x*sFrame.w\n")
    f.write("    // aoiInPixels.y = sFrame.y + areaOfInterest.y*sFrame.h\n")
    f.write("    // aoiInPixels.w = sFrame.w * areaOfInterest.w\n")
    f.write("    // aoiInPixels.h = sFrame.h * areaOfInterest*h\n")

    f.write("    sFrame.w = windowWidth / areaOfInterest.w;\n")
    f.write("    sFrame.h = (windowWidth / aoiRatio) / areaOfInterest.h;\n")
    f.write("    sFrame.x = - areaOfInterest.x * sFrame.w;\n")
    f.write("    sFrame.y = (windowHeight - windowWidth/aoiRatio)/2 - areaOfInterest.y * sFrame.h;\n")
    f.write("  } else {\n")
    f.write("    // Area of interest is taller than the window (e.g. window 16:9, aoe 4:3)\n")
    f.write("    // There will be \"black bars\" on the sides\n")
    f.write("    // We want the areaOfInterest's rect in pixels to be\n")
    f.write("    // aoiInPixels.h = windowHeight\n")
    f.write("    // aoiInPixels.y = 0\n")
    f.write("    // aoiInPixels.x = windowHeight * aoiRatio\n")
    f.write("    // aoiInPixels.w = (windowWidth - aoiInPixels.w)/2;\n")
    f.write("    // But we also know that\n")
    f.write("    // aoiInPixels.x = sFrame.x + areaOfInterest.x*sFrame.w\n")
    f.write("    // aoiInPixels.y = sFrame.y + areaOfInterest.y*sFrame.h\n")
    f.write("    // aoiInPixels.w = sFrame.w * areaOfInterest.w\n")
    f.write("    // aoiInPixels.h = sFrame.h * areaOfInterest*h\n")

    f.write("    sFrame.h = windowHeight / areaOfInterest.h;\n")
    f.write("    sFrame.w = (windowHeight * aoiRatio) / areaOfInterest.w;\n")
    f.write("    sFrame.y = - areaOfInterest.y * sFrame.h;\n")
    f.write("    sFrame.x = (windowWidth - windowHeight*aoiRatio)/2.0f - areaOfInterest.x * sFrame.w;\n")
    f.write("  }\n")
    f.write("}\n")

    f.write("void getScreenRect(SDL_Rect * rect) {\n")
    f.write("  makeAbsolute(screenRect, rect);\n")
    f.write("}\n")

    f.write("void getBackgroundRect(SDL_Rect * rect) {\n")
    f.write("  rect->x = sFrame.x;\n")
    f.write("  rect->y = sFrame.y;\n")
    f.write("  rect->w = sFrame.w;\n")
    f.write("  rect->h = sFrame.h;\n")
    f.write("}\n")

    f.write("class KeyLayout {\n")
    f.write("public:\n")
    f.write("  enum class Shape : uint8_t {\n")
    f.write("    HorizontalArrow,\n")
    f.write("    VerticalArrow,\n")
    f.write("    Round,\n")
    f.write("    SmallSquircle,\n")
    f.write("    LargeSquircle,\n")
    f.write("    NumberOfShapes\n")
    f.write("  };\n")
    f.write("  constexpr static size_t NumberOfShapes = (size_t)Shape::NumberOfShapes;\n")
    f.write("  constexpr static const char * assetName[KeyLayout::NumberOfShapes] = {\n")
    f.write("    \"horizontal_arrow.png\",\n")
    f.write("    \"vertical_arrow.png\",\n")
    f.write("    \"round.png\",\n")
    f.write("    \"small_squircle.png\",\n")
    f.write("    \"large_squircle.png\"\n")
    f.write("  };\n")

    f.write("  constexpr KeyLayout(float x, float y, Shape shape) :\n")
    f.write("    m_center{X(x), Y(y)},\n")
    f.write("    m_shape(shape) {}\n")
    f.write("  SDL_FPoint center() const { return m_center; }\n")
    f.write("  Shape shape() const { return m_shape; }\n")

    f.write("private:\n")
    f.write("  SDL_FPoint m_center;\n")
    f.write("  Shape m_shape;\n")
    f.write("};\n")

    f.write("constexpr const char * const KeyLayout::assetName[KeyLayout::NumberOfShapes];\n")
    f.write("constexpr static KeyLayout sKeyLayouts[Keyboard::NumberOfValidKeys] = {\n")

def print_key(f, key_values, shape):
    f.write("  KeyLayout(" + str(round(key_values[0] + key_values[2]/2)) + ", " + str(round(key_values[1] + key_values[3]/2)) + ", KeyLayout::Shape::" + shape + "),\n")

def print_keys(f, background_values):
    key_values = background_values["keys"]

    keys = [
        ["HorizontalArrow", [0]],
        ["VerticalArrow", [1, 2]],
        ["HorizontalArrow", [3]],
        ["Round", [4, 5]],
        ["LargeSquircle", [6, 7]],
        ["SmallSquircle", list(range(12,30))],
        ["LargeSquircle", list(range(30,35)) + list(range(36,41)) + list(range(42,47)) + list(range(48,53))]
        ]
    for k in keys:
      for v in k[1]:
        print_key(f, key_values[str(v)], k[0])

def print_after_keys(f):
    f.write("};\n")

    f.write("static void getKeyCenter(int validKeyIndex, SDL_Point * point) {\n")
    f.write("  assert(validKeyIndex >= 0 && validKeyIndex < Keyboard::NumberOfValidKeys);\n")
    f.write("  makeAbsolute(sKeyLayouts[validKeyIndex].center(), point);\n")
    f.write("}\n")

    f.write("static void getKeyRectangle(int validKeyIndex, SDL_Texture * texture, SDL_Rect * rect) {\n")
    f.write("  assert(validKeyIndex >= 0 && validKeyIndex < Keyboard::NumberOfValidKeys);\n")
    f.write("  SDL_FPoint point = sKeyLayouts[validKeyIndex].center();\n")
    f.write("  int w, h;\n")
    f.write("  SDL_QueryTexture(texture, NULL, NULL, &w, &h);\n")
    f.write("  SDL_FRect fRect;\n")
    f.write("  fRect.w = X(w);\n")
    f.write("  fRect.h = Y(h);\n")
    f.write("  fRect.x = point.x - fRect.w/2.0f;\n")
    f.write("  fRect.y = point.y - fRect.h/2.0f;\n")
    f.write("  makeAbsolute(fRect, rect);\n")
    f.write("}\n")

    f.write("static SDL_Texture * sBackgroundTexture = nullptr;\n")
    f.write("static SDL_Texture * sKeyLayoutTextures[KeyLayout::NumberOfShapes];\n")
    f.write("\n")
    f.write("void init(SDL_Renderer * renderer) {\n")
    f.write("  sBackgroundTexture = Platform::loadImage(renderer, \"background.jpg\");\n")
    f.write("  for (size_t i = 0; i < KeyLayout::NumberOfShapes; i++) {\n")
    f.write("    sKeyLayoutTextures[i] = Platform::loadImage(renderer, KeyLayout::assetName[i]);\n")
    f.write("  }\n")
    f.write("}\n")

    f.write("static int sHighlightedKeyIndex = -1;\n")

    f.write("Keyboard::Key getHighlightedKey() {\n")
    f.write("  Keyboard::Key k = Keyboard::Key::None;\n")
    f.write("  if (sHighlightedKeyIndex >= 0) {\n")
    f.write("    k = Keyboard::ValidKeys[sHighlightedKeyIndex];\n")
    f.write("  }\n")
    f.write("  return k;\n")
    f.write("}\n")

    f.write("void highlightKeyAt(SDL_Point * p) {\n")
    f.write("  int newHighlightedKeyIndex = -1;\n")
    f.write("  int minSquaredDistance = INT_MAX;\n")
    f.write("  /* The closenessThreshold is apportioned to the size of the frame. As the\n")
    f.write("   * width and the height have a constant ratio, we can compute the\n")
    f.write("   * closenessThreshold from the frame width exclusively. */\n")
    f.write("  int closenessThreshold = sFrame.w/6;\n")
    f.write("  int squaredClosenessThreshold = closenessThreshold*closenessThreshold;\n")
    f.write("  for (int i=0; i<Keyboard::NumberOfValidKeys; i++) {\n")
    f.write("    SDL_Point keyCenter;\n")
    f.write("    getKeyCenter(i, &keyCenter);\n")
    f.write("    int dx = keyCenter.x - p->x;\n")
    f.write("    int dy = keyCenter.y - p->y;\n")
    f.write("    int squaredDistance = dx*dx + dy*dy;\n")
    f.write("    if (squaredDistance < squaredClosenessThreshold && squaredDistance < minSquaredDistance) {\n")
    f.write("      minSquaredDistance = squaredDistance;\n")
    f.write("      newHighlightedKeyIndex = i;\n")
    f.write("    }\n")
    f.write("  }\n")
    f.write("  if (newHighlightedKeyIndex != sHighlightedKeyIndex) {\n")
    f.write("    sHighlightedKeyIndex = newHighlightedKeyIndex;\n")
    f.write("    Window::setNeedsRefresh();\n")
    f.write("  }\n")
    f.write("}\n")

    f.write("void unhighlightKey() {\n")
    f.write("  sHighlightedKeyIndex = -1;\n")
    f.write("  Window::setNeedsRefresh();\n")
    f.write("}\n")

    f.write("void drawHighlightedKey(SDL_Renderer * renderer) {\n")
    f.write("  if (sHighlightedKeyIndex < 0) {\n")
    f.write("    return;\n")
    f.write("  }\n")
    f.write("  int shape = static_cast<int>(sKeyLayouts[sHighlightedKeyIndex].shape());\n")
    f.write("  SDL_Texture * keyTexture = sKeyLayoutTextures[shape];\n")
    f.write("  SDL_Rect rect;\n")
    f.write("  getKeyRectangle(sHighlightedKeyIndex, keyTexture, &rect);\n")
    f.write("  SDL_RenderCopy(renderer, keyTexture, nullptr, &rect);\n")
    f.write("}\n")

    f.write("void draw(SDL_Renderer * renderer) {\n")
    f.write("  SDL_Rect backgroundRect;\n")
    f.write("  getBackgroundRect(&backgroundRect);\n")
    f.write("  SDL_RenderCopy(renderer, sBackgroundTexture, nullptr, &backgroundRect);\n")
    f.write("  drawHighlightedKey(renderer);\n")
    f.write("}\n")

    f.write("void shutdown() {\n")
    f.write("  SDL_DestroyTexture(sBackgroundTexture);\n")
    f.write("  sBackgroundTexture = nullptr;\n")
    f.write("}\n")

    f.write("#endif\n")

    f.write("}\n")
    f.write("}\n")
    f.write("}\n")

def print(input_file, output_file):
    f = open(output_file, "w")
    json_file = open(input_file, "r")
    background_values = json.load(json_file)
    json_file.close()
    print_header(f)
    print_background_areas(f, background_values)
    print_before_keys(f)
    print_keys(f, background_values)
    print_after_keys(f)
    f.close()

if not args.i.endswith(".json"):
  raise "The input file must be a .json"
if not args.o.endswith(".cpp"):
  raise "The output implementation file must be a .cpp"

print(args.i, args.o)
